(function() {

// const sampleRef = {
//     $jb_obj: {}, // real object (or parent) val - may exist only in older version of the resource. may contain $jb_id for tracking
//     $jb_childProp: 'title', // used for primitive props
// }

let isProxy = Symbol("isProxy")

class ImmutableWithJbId {
  constructor(resources) {
    this.resources = resources;
    this.objToPath = new Map();
    this.idCounter = 1;
    this.allowedTypes = [Object.getPrototypeOf({}),Object.getPrototypeOf([])];
    this.resourceChange = new jb.rx.Subject();
    this.observables = [];
    jb.delay(1).then(_=>{
        jb.ui.originalResources = jb.resources
        const resourcesObj = resources()
        resourcesObj.$jb_id = this.idCounter++
        this.objToPath.set(resourcesObj.$jb_id,[])
        this.propagateResourceChangeToObservables()
    })
  }
  resourceReferred(resName) {
    const resource = this.resources()[resName]
    if (!this.objToPath.has(resource))
    this.addObjToMap(resource,[resName])
  }
  doOp(ref,opOnRef,srcCtx,doNotNotify) {
    const opVal = opOnRef.$set || opOnRef.$merge || opOnRef.$push || opOnRef.$splice;
    if (!this.isRef(ref))
      ref = this.asRef(ref);
    jb.log('doOp',[this.asStr(ref),opVal,...arguments]);

    const path = this.pathOfRef(ref), op = {}, oldVal = this.valOfPath(path);
    if (!path || ref.$jb_val) return;
    if (opOnRef.$set && opOnRef.$set == oldVal) return;
    path.forEach((p,i)=> { // hash ancestors with $jb_id because the objects will be re-generated by redux
        const innerPath = path.slice(0,i+1)
        const val = this.valOfPath(innerPath)
        if (val && typeof val === 'object' && !val.$jb_id) {
            val.$jb_id = this.idCounter++
            this.objToPath.delete(val)
            this.objToPath.set(val.$jb_id,innerPath)
        }
    })
    jb.path(op,path,opOnRef); // create op as nested object
    const opEvent = {op: opOnRef, path, ref, srcCtx, oldVal, opVal, timeStamp: new Date().getTime()};
    this.resources(jb.ui.update(this.resources(),op),opEvent);
    const newVal = (opVal != null && opVal[isProxy]) ? opVal : this.valOfPath(path);
    if (opOnRef.$push) {
        this.addObjToMap(opOnRef.$push,[...path,oldVal.length])
    } else {
        // TODO: make is more effecient in case of $merge, $splice
        this.removeObjFromMap(oldVal)
        this.addObjToMap(newVal,path)
    }
    opEvent.newVal = newVal;
    if (!doNotNotify)
        this.resourceChange.next(opEvent);
    return opEvent;
  }
  addObjToMap(top,path) {
    if (!top || top[isProxy] || top.$jb_val || typeof top !== 'object' || this.allowedTypes.indexOf(Object.getPrototypeOf(top)) == -1) return
    if (top.$jb_id) {
        this.objToPath.set(top.$jb_id,path)
        this.objToPath.delete(top)
    } else {
        this.objToPath.set(top,path)
    }
    Object.keys(top).filter(key=>typeof top[key] === 'object' && key.indexOf('$jb_') != 0)
        .forEach(key => this.addObjToMap(top[key],[...path,key]))
  }
  removeObjFromMap(top) {
    if (!top || typeof top !== 'object' || this.allowedTypes.indexOf(Object.getPrototypeOf(top)) == -1) return
    this.objToPath.delete(top)
    if (top.$jb_id)
        this.objToPath.delete(top.$jb_id)
    Object.keys(top).filter(key=>key=>typeof top[key] === 'object' && key.indexOf('$jb_') != 0).forEach(key => this.removeObjFromMap(top[key]))
  }
  refreshMapDown(top) {
    const ref = this.asRef(top)
    const path = ref && ref.path && ref.path()
    if (path)
      this.addObjToMap(top,path)
  }
  pathOfRef(ref) {
    if (ref.$jb_path)
      return ref.$jb_path()
    const path = this.isRef(ref) && (this.objToPath.get(ref.$jb_obj) || this.objToPath.get(ref.$jb_obj.$jb_id))
    if (path && ref.$jb_childProp)
        return [...path, ref.$jb_childProp]
    return path
  }
  asRef(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    const path = this.objToPath.get(obj) || this.objToPath.get(obj.$jb_id)
    if (path)
        return { $jb_obj: this.valOfPath(path), handler: this, path: function() { return this.handler.pathOfRef(this)} }
    return obj;
  }
  valOfPath(path) {
    return this.cleanVal(path.reduce((o,p)=>o && o[p],this.resources()))
  }
  refOfPath(path) {
    const val = this.valOfPath(path);
    if (!val || typeof val !== 'object' && path.length > 0) {
      const parent = this.asRef(this.valOfPath(path.slice(0,-1)));
      if (this.isRef(parent)) 
        return Object.assign({},parent,{$jb_childProp: path.slice(-1)[0]})
      jb.logError('reOfPath can not find parent ref',path.join('~'))
    }
    return this.asRef(val)
  }
  asStr(ref) { // for logs
    return this.pathOfRef(ref).join('~')
  }
  isValid(ref) {
    return this.isRef(ref) && this.pathOfRef(ref)
  }
  val(ref) {
    if (ref == null) return ref;
    if (ref.$jb_val) return ref.$jb_val();

    if (!ref.$jb_obj) return ref;
    if (ref.handler != this) {
      if (typeof ref.handler.val != 'function') debugger
      return ref.handler.val(ref)
    }
    const path = this.pathOfRef(ref);
    if (!path) {
      debugger
      this.pathOfRef(ref)
    }
    return this.valOfPath(path)
  }
  isRef(ref) {
    return ref && (ref.$jb_obj || ref.$jb_val);
  }
  objectProperty(obj,prop,ctx) {
    jb.log('immutable',['objectProperty',...arguments]);
    if (!obj)
      return jb.logError('objectProperty: null obj',ctx);
    var ref = this.asRef(obj);
    if (ref && ref.$jb_obj) {
      return {$jb_obj: ref.$jb_obj, $jb_childProp: prop, handler: this, path: function() { return this.handler.pathOfRef(this)}}
    } else {
      return obj[prop]; // not reffable
    }
  }
  writeValue(ref,value,srcCtx) {
    if (!ref || !this.isRef(ref) || !this.pathOfRef(ref))
      return jb.logError('writeValue: err in ref', srcCtx, ref, value);

    jb.log('writeValue',['immutable',this.asStr(ref),value,ref,srcCtx]);
    if (ref.$jb_val)
      return ref.$jb_val(value);
    if (this.val(ref) === value) return;
    return this.doOp(ref,{$set: this.createSecondaryLink(value)},srcCtx)
  }
  createSecondaryLink(val) {
    if (val && typeof val === 'object' && !val.$jb_secondaryLink) {
      const ref = this.asRef(val);
      if (ref.$jb_obj)
        return new Proxy(val, {
          get: (o,p) => (p === isProxy) ? true : (p === '$jb_secondaryLink' ? {val} : (jb.val(this.asRef(val)))[p]),
          set: (o,p,v) => o[p] = v
        })
    }
    return val;
  }
  cleanVal(val) {
    return val && val.$jb_secondaryLink && val.$jb_secondaryLink.val || val
  }
  splice(ref,args,srcCtx) {
    return this.doOp(ref,{$splice: args },srcCtx)
  }
  move(fromRef,toRef,srcCtx) {
    const fromPath = this.pathOfRef(fromRef), toPath = this.pathOfRef(toRef);
    const sameArray = fromPath.slice(0,-1).join('~') == toPath.slice(0,-1).join('~');
    const fromIndex = Number(fromPath.slice(-1));
    const toIndex = Number(toPath.slice(-1));
    const fromArray = this.refOfPath(fromPath.slice(0,-1)),toArray = this.refOfPath(toPath.slice(0,-1));
    if (isNaN(fromIndex) || isNaN(toIndex))
        return jb.logError('move: not array element',srcCtx,fromRef,toRef);

    var valToMove = jb.val(fromRef);
    if (sameArray) {
        if (fromIndex < toIndex) toIndex--; // the deletion changes the index
        return this.doOp(fromArray,{$splice: [[fromIndex,1],[toIndex,0,valToMove]] },srcCtx)
    }
    var events = [
        this.doOp(fromArray,{$splice: [[fromIndex,1]] },srcCtx,true),
        this.doOp(toArray,{$splice: [[toIndex,0,valToMove]] },srcCtx,true),
    ]
    events.forEach(opEvent=>this.resourceChange.next(opEvent))
  }
  push(ref,value,srcCtx) {
    return this.doOp(ref,{$push: this.createSecondaryLink(value)},srcCtx)
  }
  merge(ref,value,srcCtx) {
    return this.doOp(ref,{$merge: this.createSecondaryLink(value)},srcCtx)
  }
  getOrCreateObservable(req) {
      const subject = new jb.rx.Subject()
      const entry = { ...req, subject}
      this.observables.push(entry);
      this.observables.sort((e1,e2) => comparePaths(e1.cmp && e1.cmp.ctx.path, e2.cmp && e2.cmp.ctx.path))
      req.cmp.destroyed.then(_=> {
          this.observables.splice(this.observables.indexOf(entry), 1);
          subject.complete()
      });
      return subject
  }
  refObservable(ref,cmp,settings={}) {
    jb.log('registerCmpObservable',[cmp.ctx, ...arguments])
    if (ref && ref.$jb_observable)
      return ref.$jb_observable(cmp);
    if (!ref || !this.isRef(ref))
      return jb.rx.Observable.of().takeUntil(cmp.destroyed);

    return this.getOrCreateObservable({ref,cmp,...settings})
  }

  propagateResourceChangeToObservables() {
      this.resourceChange.subscribe(e=>{
          const changed_path = this.pathOfRef(e.ref);
          if (changed_path)
            this.observables.forEach(obs=>{
                const diff = comparePaths(changed_path, this.pathOfRef(obs.ref))
                if (diff == -1 || diff == 0 || diff == 1 && obs.includeChildren) {
                    jb.log('notifyCmpObservable',['notify change',e.srcCtx,obs,e])
                    obs.subject.next(e)
                }
            })
      })
    }
}

// 0- equals, -1,1 means contains -2,2 lexical
function comparePaths(path1,path2) {
    path1 = path1 || ''
    path2 = path2 || ''
    let i=0;
    while(path1[i] === path2[i] && i < path1.length) i++;
    if (i == path1.length && i == path2.length) return 0;
    if (i == path1.length && i < path2.length) return -1;
    if (i == path2.length && i < path1.length) return 1;
    return path1[i] < path2[i] ? -2 : 2
}

function resourcesRef(val) {
  if (typeof val == 'undefined')
    return jb.resources;
  else
    jb.resources = val;
}
jb.valueByRefHandler = new ImmutableWithJbId(resourcesRef);

jb.ui.refObservable = (ref,cmp,settings) =>
  jb.refHandler(ref).refObservable(ref,cmp,settings);

jb.ui.ImmutableWithJbId = ImmutableWithJbId;
jb.ui.resourceChange = jb.valueByRefHandler.resourceChange;


})()
